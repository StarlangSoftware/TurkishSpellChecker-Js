"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrieBasedSpellChecker = void 0;
const NGramSpellChecker_1 = require("./NGramSpellChecker");
const Trie_1 = require("./Trie");
const TrieCandidate_1 = require("./TrieCandidate");
const Queue_1 = require("nlptoolkit-datastructure/dist/Queue");
class TrieBasedSpellChecker extends NGramSpellChecker_1.NGramSpellChecker {
    generatedWords;
    trie;
    /**
     * A constructor of {@link TrieBasedSpellChecker} class which takes a {@link FsmMorphologicalAnalyzer}, an {@link NGram}
     * and a {@link SpellCheckerParameter} as inputs. Then, calls its super class {@link NGramSpellChecker} with given inputs.
     *
     * @param fsm       {@link FsmMorphologicalAnalyzer} type input.
     * @param nGram     {@link NGram} type input.
     * @param parameter {@link SpellCheckerParameter} type input.
     */
    constructor(fsm, nGram, parameter) {
        super(fsm, nGram, parameter);
        this.loadTrieDictionaries();
        this.prepareTrie();
    }
    /**
     * {@inheritDoc}
     * This method also loads generated words from a file.
     */
    loadTrieDictionaries() {
        this.generatedWords = new Array();
        let data = this.getFile("generated_words.txt");
        let lines = data.split("\n");
        for (let line of lines) {
            this.generatedWords.push(line);
        }
    }
    /**
     * Populates a Trie data structure with a set of strings generated by the morphological analyzer.
     *
     * @see Trie
     * @see FsmMorphologicalAnalyzer#generateAllParses(TxtWord, int)
     */
    prepareTrie() {
        this.trie = new Trie_1.Trie();
        for (let word of this.generatedWords) {
            this.trie.insert(word);
        }
    }
    /**
     * Checks if the trie object contains the candidate.
     * If it does, it compares the penalty of the candidate in the results with the penalty of the candidate variable.
     * If the current penalty of the candidate in the results is less than or equal to the current penalty
     * of the candidate variable, it removes the first element of the candidates ArrayDeque.
     * If not, it adds the candidate variable to the results ArrayList and removes the first element.
     * If the trie object does not contain the candidate, it checks if the current penalty and the current
     * index of the candidate variable and if they are not at the limit,
     * it moves the index one character to the right and generates new candidates.
     *
     * @param word     the word to search for candidates for
     * @param sentence the sentence containing the word
     * @return an ArrayList of Candidate objects representing the potential candidates
     */
    candidateList(word, sentence) {
        let candidates = new Queue_1.Queue(100000);
        let results = new Array();
        candidates.enqueue(new TrieCandidate_1.TrieCandidate(word.getName(), -1, 0));
        let penaltyLimit = Math.min(word.charCount() / 2.0, 3.0);
        while (!candidates.isEmpty()) {
            let candidate = candidates.peek();
            let candidateName = candidate.getName();
            if (this.trie.search(candidateName)) {
                let itemIndex = this.searchCandidates(results, candidate);
                if (itemIndex != -1 && results[itemIndex].getCurrentPenalty() <= candidate.getCurrentPenalty()) {
                    candidates.dequeue();
                }
                else {
                    results.push(candidates.dequeue());
                }
            }
            else {
                if (candidate.getCurrentPenalty() > penaltyLimit - 1 || candidate.getCurrentIndex() >= candidateName.length - 1) {
                    candidates.dequeue();
                }
                else {
                    candidate = candidates.dequeue();
                    candidate.nextIndex();
                    candidates.enqueue(new TrieCandidate_1.TrieCandidate(candidate.getName(), candidate.getCurrentIndex(), candidate.getCurrentPenalty()));
                    let newCandidates = this.generateTrieCandidates(candidate);
                    for (let newCandidate of newCandidates) {
                        candidates.enqueue(newCandidate);
                    }
                }
            }
        }
        return results;
    }
    /**
     * Searches the intermediate results array for the given candidate. The search is done based on name of the candidate.
     * @param results Array to search for candidate
     * @param candidate Candidate to be searched.
     * @return Index of the candidate in the results array. If it does not exist, returns -1.
     */
    searchCandidates(results, candidate) {
        for (let i = 0; i < results.length; i++) {
            if (results[i].getName() == candidate.getName()) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Generates a set of candidates based on a given TrieCandidate.
     * The generated candidates are created by applying a set of operations to
     * the input TrieCandidate. The possible operations are:
     * De-asciification: replacing certain ASCII characters with their non-ASCII counterparts.
     * Substitution: replacing a single character with another character.
     * Insertion: adding a single character to the string.
     * Deletion: removing a single character from the string.
     * Transposition: swapping the positions of two adjacent characters in the string.
     *
     * @param candidate the input TrieCandidate
     * @return a set of candidate strings, each contained in a TrieCandidate object
     */
    generateTrieCandidates(candidate) {
        let candidates = new Array();
        let currentName = candidate.getName();
        let currentIndex = candidate.getCurrentIndex();
        let currentPenalty = candidate.getCurrentPenalty();
        let deasciifiedWord;
        let currentNode = this.trie.getTrieNode(currentName.substring(0, currentIndex));
        if (currentNode == null) {
            return candidates;
        }
        let letters = currentNode.childrenToString();
        let ch2 = "";
        switch (currentName.charAt(currentIndex)) {
            case 'c':
                ch2 = 'ç';
                break;
            case 'g':
                ch2 = 'ğ';
                break;
            case 'i':
                ch2 = 'ı';
                break;
            case 's':
                ch2 = 'ş';
                break;
            case 'o':
                ch2 = 'ö';
                break;
            case 'u':
                ch2 = 'ü';
                break;
        }
        if (ch2 != "") {
            deasciifiedWord = currentName.substring(0, currentIndex) + ch2 + currentName.substring(currentIndex + 1);
        }
        else {
            deasciifiedWord = currentName;
        }
        if (deasciifiedWord != currentName && this.trie.startsWith(deasciifiedWord.substring(0, currentIndex + 1))) {
            candidates.push(new TrieCandidate_1.TrieCandidate(deasciifiedWord, currentIndex, currentPenalty + 0.2));
        }
        for (let j = 0; j < letters.length; j++) {
            let replaced = currentName.substring(0, currentIndex) + letters.charAt(j) + currentName.substring(currentIndex + 1);
            candidates.push(new TrieCandidate_1.TrieCandidate(replaced, currentIndex, currentPenalty + 1));
            let added = currentName.substring(0, currentIndex) + letters.charAt(j) + currentName.substring(currentIndex);
            candidates.push(new TrieCandidate_1.TrieCandidate(added, currentIndex, currentPenalty + 1));
            let addedLast = currentName + letters.charAt(j);
            if (this.trie.startsWith(addedLast)) {
                candidates.push(new TrieCandidate_1.TrieCandidate(addedLast, currentIndex, currentPenalty + 1));
            }
        }
        let deleted = currentName.substring(0, currentIndex) + currentName.substring(currentIndex + 1);
        if (deleted.length > 1) {
            candidates.push(new TrieCandidate_1.TrieCandidate(deleted, currentIndex - 1, currentPenalty + 1));
        }
        if (currentIndex < currentName.length - 1 && currentName.charAt(currentIndex) != currentName.charAt(currentIndex + 1) && this.trie.startsWith(currentName.substring(0, currentIndex + 2))) {
            let swapped = currentName.substring(0, currentIndex) + currentName.charAt(currentIndex + 1) + currentName.charAt(currentIndex) + currentName.substring(currentIndex + 2);
            candidates.push(new TrieCandidate_1.TrieCandidate(swapped, currentIndex, currentPenalty + 1));
        }
        return candidates;
    }
}
exports.TrieBasedSpellChecker = TrieBasedSpellChecker;
//# sourceMappingURL=TrieBasedSpellChecker.js.map