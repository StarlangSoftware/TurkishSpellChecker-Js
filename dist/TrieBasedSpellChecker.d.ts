import { NGramSpellChecker } from "./NGramSpellChecker";
import { FsmMorphologicalAnalyzer } from "nlptoolkit-morphologicalanalysis/dist/MorphologicalAnalysis/FsmMorphologicalAnalyzer";
import { NGram } from "nlptoolkit-ngram/dist/NGram";
import { SpellCheckerParameter } from "./SpellCheckerParameter";
import { Word } from "nlptoolkit-dictionary/dist/Dictionary/Word";
import { Sentence } from "nlptoolkit-corpus/dist/Sentence";
import { Candidate } from "./Candidate";
export declare class TrieBasedSpellChecker extends NGramSpellChecker {
    private generatedWords;
    private trie;
    /**
     * A constructor of {@link TrieBasedSpellChecker} class which takes a {@link FsmMorphologicalAnalyzer}, an {@link NGram}
     * and a {@link SpellCheckerParameter} as inputs. Then, calls its super class {@link NGramSpellChecker} with given inputs.
     *
     * @param fsm       {@link FsmMorphologicalAnalyzer} type input.
     * @param nGram     {@link NGram} type input.
     * @param parameter {@link SpellCheckerParameter} type input.
     */
    constructor(fsm: FsmMorphologicalAnalyzer, nGram: NGram<string>, parameter?: SpellCheckerParameter);
    /**
     * {@inheritDoc}
     * This method also loads generated words from a file.
     */
    protected loadTrieDictionaries(): void;
    /**
     * Populates a Trie data structure with a set of strings generated by the morphological analyzer.
     *
     * @see Trie
     * @see FsmMorphologicalAnalyzer#generateAllParses(TxtWord, int)
     */
    private prepareTrie;
    /**
     * Checks if the trie object contains the candidate.
     * If it does, it compares the penalty of the candidate in the results with the penalty of the candidate variable.
     * If the current penalty of the candidate in the results is less than or equal to the current penalty
     * of the candidate variable, it removes the first element of the candidates ArrayDeque.
     * If not, it adds the candidate variable to the results ArrayList and removes the first element.
     * If the trie object does not contain the candidate, it checks if the current penalty and the current
     * index of the candidate variable and if they are not at the limit,
     * it moves the index one character to the right and generates new candidates.
     *
     * @param word     the word to search for candidates for
     * @param sentence the sentence containing the word
     * @return an ArrayList of Candidate objects representing the potential candidates
     */
    candidateList(word: Word, sentence: Sentence): Array<Candidate>;
    /**
     * Searches the intermediate results array for the given candidate. The search is done based on name of the candidate.
     * @param results Array to search for candidate
     * @param candidate Candidate to be searched.
     * @return Index of the candidate in the results array. If it does not exist, returns -1.
     */
    private searchCandidates;
    /**
     * Generates a set of candidates based on a given TrieCandidate.
     * The generated candidates are created by applying a set of operations to
     * the input TrieCandidate. The possible operations are:
     * De-asciification: replacing certain ASCII characters with their non-ASCII counterparts.
     * Substitution: replacing a single character with another character.
     * Insertion: adding a single character to the string.
     * Deletion: removing a single character from the string.
     * Transposition: swapping the positions of two adjacent characters in the string.
     *
     * @param candidate the input TrieCandidate
     * @return a set of candidate strings, each contained in a TrieCandidate object
     */
    private generateTrieCandidates;
}
