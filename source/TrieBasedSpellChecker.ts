import {NGramSpellChecker} from "./NGramSpellChecker";
import {Trie} from "./Trie";
import {
    FsmMorphologicalAnalyzer
} from "nlptoolkit-morphologicalanalysis/dist/MorphologicalAnalysis/FsmMorphologicalAnalyzer";
import {NGram} from "nlptoolkit-ngram/dist/NGram";
import {SpellCheckerParameter} from "./SpellCheckerParameter";
import * as fs from "fs";
import {Word} from "nlptoolkit-dictionary/dist/Dictionary/Word";
import {Sentence} from "nlptoolkit-corpus/dist/Sentence";
import {Candidate} from "./Candidate";
import {TrieCandidate} from "./TrieCandidate";
import * as Console from "console";

export class TrieBasedSpellChecker extends NGramSpellChecker{

    private generatedWords: Array<string>
    private trie: Trie

    /**
     * A constructor of {@link TrieBasedSpellChecker} class which takes a {@link FsmMorphologicalAnalyzer}, an {@link NGram}
     * and a {@link SpellCheckerParameter} as inputs. Then, calls its super class {@link NGramSpellChecker} with given inputs.
     *
     * @param fsm       {@link FsmMorphologicalAnalyzer} type input.
     * @param nGram     {@link NGram} type input.
     * @param parameter {@link SpellCheckerParameter} type input.
     */
    constructor(fsm: FsmMorphologicalAnalyzer, nGram: NGram<string>, parameter: SpellCheckerParameter) {
        super(fsm, nGram, parameter);
        this.loadTrieDictionaries()
        this.prepareTrie()
    }

    /**
     * {@inheritDoc}
     * This method also loads generated words from a file.
     */
    protected loadTrieDictionaries(){
        this.generatedWords = new Array<string>()
        let data = fs.readFileSync("generated_words.txt", 'utf8')
        let lines = data.split("\n")
        for (let line of lines){
            this.generatedWords.push(line)
        }
    }

    /**
     * Populates a Trie data structure with a set of strings generated by the morphological analyzer.
     *
     * @see Trie
     * @see FsmMorphologicalAnalyzer#generateAllParses(TxtWord, int)
     */
    private prepareTrie(){
        this.trie = new Trie()
        for (let word of this.generatedWords) {
            this.trie.insert(word)
        }
    }

    /**
     * Checks if the trie object contains the candidate.
     * If it does, it compares the penalty of the candidate in the results with the penalty of the candidate variable.
     * If the current penalty of the candidate in the results is less than or equal to the current penalty
     * of the candidate variable, it removes the first element of the candidates ArrayDeque.
     * If not, it adds the candidate variable to the results ArrayList and removes the first element.
     * If the trie object does not contain the candidate, it checks if the current penalty and the current
     * index of the candidate variable and if they are not at the limit,
     * it moves the index one character to the right and generates new candidates.
     *
     * @param word     the word to search for candidates for
     * @param sentence the sentence containing the word
     * @return an ArrayList of Candidate objects representing the potential candidates
     */
    candidateList(word: Word, sentence: Sentence): Array<Candidate>{
        let candidates = new Array<TrieCandidate>()
        let results = new Array<Candidate>()
        candidates.push(new TrieCandidate(word.getName(), -1, 0))
        let penaltyLimit = Math.min(word.charCount() / 2.0, 3.0)
        while (candidates.length > 0) {
            let candidate = candidates[0]
            let candidateName = candidate.getName()
            if (this.trie.search(candidateName)) {
                let itemIndex = this.searchCandidates(results, candidate)
                if (itemIndex != -1 && (<TrieCandidate>results[itemIndex]).getCurrentPenalty() <= candidate.getCurrentPenalty()) {
                    candidates.shift()
                } else {
                    results.push(candidates.shift())
                }
            } else {
                if (candidate.getCurrentPenalty() > penaltyLimit - 1 || candidate.getCurrentIndex() >= candidateName.length - 1) {
                    candidates.shift()
                } else {
                    candidate = candidates.shift()
                    candidate.nextIndex()
                    candidates.push(new TrieCandidate(candidate.getName(), candidate.getCurrentIndex(), candidate.getCurrentPenalty()))
                    let newCandidates = this.generateTrieCandidates(candidate)
                    candidates.push(...newCandidates)
                }
            }
        }
        return results
    }

    private searchCandidates(results: Array<Candidate>, candidate: TrieCandidate): number{
        for (let i = 0; i < results.length; i++){
            if (results[i].getName() == candidate.getName()){
                return i
            }
        }
        return -1
    }

    /**
     * Generates a set of candidates based on a given TrieCandidate.
     * The generated candidates are created by applying a set of operations to
     * the input TrieCandidate. The possible operations are:
     * De-asciification: replacing certain ASCII characters with their non-ASCII counterparts.
     * Substitution: replacing a single character with another character.
     * Insertion: adding a single character to the string.
     * Deletion: removing a single character from the string.
     * Transposition: swapping the positions of two adjacent characters in the string.
     *
     * @param candidate the input TrieCandidate
     * @return a set of candidate strings, each contained in a TrieCandidate object
     */
    private generateTrieCandidates(candidate: TrieCandidate): Array<TrieCandidate>{
        let candidates = new Array<TrieCandidate>()
        let currentName = candidate.getName()
        let currentIndex = candidate.getCurrentIndex()
        let currentPenalty = candidate.getCurrentPenalty()
        let deasciifiedWord
        let currentNode = this.trie.getTrieNode(currentName.substring(0, currentIndex))
        if (currentNode == null) {
            return candidates;
        }
        let letters = currentNode.childrenToString()
        let ch2 = ""
        switch (currentName.charAt(currentIndex)) {
            case 'c':
                ch2 = 'ç'
                break;
            case 'g':
                ch2 = 'ğ'
                break;
            case 'i':
                ch2 = 'ı'
                break;
            case 's':
                ch2 = 'ş'
                break;
            case 'o':
                ch2 = 'ö'
                break;
            case 'u':
                ch2 = 'ü'
                break;
        }
        if (ch2 != ""){
            deasciifiedWord = currentName.substring(0, currentIndex) + ch2 + currentName.substring(currentIndex + 1)
        } else {
            deasciifiedWord = currentName
        }
        if (deasciifiedWord != currentName && this.trie.startsWith(deasciifiedWord.substring(0, currentIndex + 1))) {
            candidates.push(new TrieCandidate(deasciifiedWord, currentIndex, currentPenalty + 0.2))
        }
        for (let j = 0; j < letters.length; j++) {
            let replaced = currentName.substring(0, currentIndex) + letters.charAt(j) + currentName.substring(currentIndex + 1)
            candidates.push(new TrieCandidate(replaced, currentIndex, currentPenalty + 1))
            let added = currentName.substring(0, currentIndex) + letters.charAt(j) + currentName.substring(currentIndex)
            candidates.push(new TrieCandidate(added, currentIndex, currentPenalty + 1))
            let addedLast = currentName + letters.charAt(j)
            if (this.trie.startsWith(addedLast)) {
                candidates.push(new TrieCandidate(addedLast, currentIndex, currentPenalty + 1))
            }
        }
        let deleted = currentName.substring(0, currentIndex) + currentName.substring(currentIndex + 1)
        if (deleted.length > 1) {
            candidates.push(new TrieCandidate(deleted, currentIndex - 1, currentPenalty + 1))
        }
        if (currentIndex < currentName.length - 1 && currentName.charAt(currentIndex) != currentName.charAt(currentIndex + 1) && this.trie.startsWith(currentName.substring(0, currentIndex + 2))) {
            let swapped = currentName.substring(0, currentIndex) + currentName.charAt(currentIndex + 1) + currentName.charAt(currentIndex) + currentName.substring(currentIndex + 2)
            candidates.push(new TrieCandidate(swapped, currentIndex, currentPenalty + 1))
        }
        return candidates
    }
}